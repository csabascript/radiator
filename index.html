<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Radi√°tor szimul√°tor ‚Äì Alfa</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        background: #f5f5f5;
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
        background: white;
        margin: 0;
        padding: 0;
      }

      header#controls {
        height: 80px;
        display: flex;
        align-items: center;
        padding: 0 16px;
        background: #fafafa;
        border-bottom: 1px solid #ddd;
        box-sizing: border-box;
        flex-wrap: wrap;
      }

      header#controls label {
        font-size: 14px;
      }

      header#controls select {
        margin-left: 8px;
        padding: 4px 8px;
      }

      .inner {
        max-width: 800px;
        margin: 0 auto;
        width: 100%;
        display: flex;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }
      .logo {
        font-size: 34px;
        line-height: 1;
        margin-right: 8px;
      }

      footer .inner {
        display: block; /* stack lines in footer */
      }
      footer {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        font-size: 16px;
        color: #444;
        background: #fafafa;
        border-top: 1px solid #ddd;
        padding: 8px 12px;
        box-sizing: border-box;
      }
      #footerCurrent {
        text-align: center;
        font-weight: 600;
        font-size: 22px;
      }
      .info-icon {
        margin-left: 6px;
        cursor: help;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <header id="controls">
      <div class="inner">
        <div class="logo">‚ô®Ô∏è</div>
        <label style="margin-right: 16px">
          Radi√°tor t√≠pusa:
          <select id="radiatorType">
            <option value="11">Ac√©l ‚Äì 11-es t√≠pus</option>
            <option value="21">Ac√©l ‚Äì 21-es t√≠pus</option>
            <option value="22" selected>Ac√©l ‚Äì 22-es t√≠pus</option>
            <option value="33">Ac√©l ‚Äì 33-as t√≠pus</option>
            <option value="aluminium">Alum√≠nium</option>
          </select>
        </label>

        <label style="margin-right: 16px">
          Szobah≈ëm√©rs√©klet cel:
          <input id="roomTemp" type="number" min="5" max="30" step="1" />
          ¬∞C
        </label>
      </div>
    </header>

    <canvas id="canvas"></canvas>

    <footer>
      <div class="inner">
        <div id="footerCurrent" style="margin-top: 6px"></div>
      </div>
    </footer>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        const headerHeight = document.getElementById("controls").offsetHeight;
        const footerHeight = document.querySelector("footer").offsetHeight;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - headerHeight - footerHeight;
        canvas.style.marginTop = "0";

        // Center radiator horizontally on load/resize
        radiator.x = snap((canvas.width - radiator.w) / 2);

        redraw();
      }

      window.addEventListener("resize", resizeCanvas);

      const gridSize = 60;
      const MM_PER_GRID = 100; // 1 grid cell = 200 mm (visual grid stays the same)
      const CONSTRUCTION_GAP = 14;
      const CONSTRUCTION_HEIGHT = 28;

      function drawGrid() {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#eee";
        for (let x = 0; x <= canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      function drawConstructionBox() {
        // Position: attached to radiator, above it, with a gap
        const x = radiator.x;
        const y = radiator.y - CONSTRUCTION_GAP - CONSTRUCTION_HEIGHT;
        const w = radiator.w;
        const h = CONSTRUCTION_HEIGHT;

        // Background outline
        ctx.strokeStyle = "#aaa";
        ctx.strokeRect(x, y, w, h);

        let sequence;

        switch (radiatorType) {
          case "11":
            sequence = ["P", "F"];
            break;
          case "21":
            sequence = ["P", "F", "P"];
            break;
          case "22":
            sequence = ["P", "F", "P", "F"];
            break;
          case "33":
            sequence = ["P", "F", "P", "F", "P", "F"];
            break;
          case "aluminium":
            sequence = ["A"];
            break;
        }

        if (sequence[0] === "A") {
          ctx.fillStyle = "#c8c8c8";
          ctx.fillRect(x, y, w, h);

          ctx.strokeStyle = "#c8c8c8";
          for (let sx = x + 6; sx < x + w; sx += 10) {
            ctx.beginPath();
            ctx.moveTo(sx, y + 4);
            ctx.lineTo(sx, y + h - 4);
            ctx.stroke();
          }
          return;
        }

        const unitW = w / sequence.length;

        for (let i = 0; i < sequence.length; i++) {
          const bx = x + i * unitW;
          const type = sequence[i];

          if (type === "P") {
            // Panel
            ctx.fillStyle = "#c8c8c8";
            ctx.fillRect(bx, y, unitW, h);
          } else {
            // Convector (vertical snake/zig-zag abstraction)
            ctx.strokeStyle = "#c8c8c8";
            ctx.lineWidth = 2;

            const padding = 4;
            const startY = y + padding;
            const endY = y + h - padding;
            const stepX = 6;

            ctx.beginPath();

            let goingDown = true;
            let cx = bx + padding;

            ctx.moveTo(cx, startY);

            while (cx < bx + unitW - padding) {
              if (goingDown) {
                ctx.lineTo(cx, endY);
              } else {
                ctx.lineTo(cx, startY);
              }
              cx += stepX;
              ctx.lineTo(cx, goingDown ? endY : startY);
              goingDown = !goingDown;
            }

            ctx.stroke();
            ctx.lineWidth = 1;
          }
        }
      }

      // Added slider state + bounds
      let deltaDrop = 10;

      let flowTemp = 70; // IN temperature
      let returnTemp = 60; // OUT temperature

      const FLOW_MIN = 40;
      const FLOW_MAX = 90;
      const RETURN_MIN = 20;

      let draggingInSlider = false;
      let draggingOutSlider = false;

      const radiator = {
        x: gridSize * 2,
        y: gridSize * 2,
        w: gridSize * 12, // 1200 mm default width
        h: gridSize * 6, // 600 mm default height
        resizing: false,
        dragging: false,
        dragOffsetX: 0,
        dragOffsetY: 0,
        inflow: "tl", // default IN: top-left
        outflow: "tr", // default OUT: top-right
      };

      let radiatorType = "22";
      let roomTemp = 22;
      document.getElementById("roomTemp").value = roomTemp;

      function getConnectors() {
        return {
          tl: { x: radiator.x, y: radiator.y },
          tr: { x: radiator.x + radiator.w, y: radiator.y },
        };
      }

      // Updated computeDeltaT() to use explicit temps
      function computeDeltaT() {
        const avgWaterTemp = (flowTemp + returnTemp) / 2;
        return Math.max(5, avgWaterTemp - roomTemp);
      }

      // Updated getFlowReturnTemps() to use explicit temps
      function getFlowReturnTemps() {
        return { flow: flowTemp, ret: returnTemp };
      }

      function estimateRadiatorWatts() {
        // Face area (m¬≤)
        const widthM = ((radiator.w / gridSize) * MM_PER_GRID) / 1000;
        const heightM = ((radiator.h / gridSize) * MM_PER_GRID) / 1000;
        const areaM2 = Math.max(0, widthM * heightM);

        // EN 442 calibrated baselines (ŒîT50), per m¬≤ of front face
        // Aligned to real catalogue data (e.g. Stelrad / Wickes)
        const wattsPerM2ByType = {
          11: 1500, // ~Type 11 600√ó1200 ‚âà 1000‚Äì1100 W
          21: 2200, // between 11 and 22
          22: 2800, // ~Type 22 600√ó1200 ‚âà 1900‚Äì2050 W
          33: 4000, // ~Type 33 600√ó1200 ‚âà 2800‚Äì3000 W
          aluminium: 3000,
        };

        const baseWattsPerM2 = wattsPerM2ByType[radiatorType] ?? 1200;
        const baseWatts = areaM2 * baseWattsPerM2;

        // Estimate ŒîT from user-friendly inputs
        const deltaT = computeDeltaT();

        // Radiator output scaling (non-linear)
        const exponent = 1.3;
        const scaledWatts = baseWatts * Math.pow(deltaT / 50, exponent);

        return scaledWatts;
      }

      function drawRadiator() {
        ctx.lineWidth = 1;

        // Compute wattage first so color can reflect output strength
        const watts = estimateRadiatorWatts();
        const wattsRounded = Math.round(watts / 50) * 50;

        // White radiator body
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(radiator.x, radiator.y, radiator.w, radiator.h);

        // Snake/zig-zag texture over the radiator (subtle, light gray)
        ctx.strokeStyle = "#c8c8c8";
        ctx.lineWidth = 2;

        const padding = 6;
        const top = radiator.y + padding;
        const bottom = radiator.y + radiator.h - padding;
        const stepX = 10;

        ctx.beginPath();
        let goingDown = true;
        let texX = radiator.x + padding;

        ctx.moveTo(texX, top);

        while (texX < radiator.x + radiator.w - padding) {
          if (goingDown) {
            ctx.lineTo(texX, bottom);
          } else {
            ctx.lineTo(texX, top);
          }
          texX += stepX;
          ctx.lineTo(texX, goingDown ? bottom : top);
          goingDown = !goingDown;
        }

        ctx.stroke();
        ctx.lineWidth = 1;

        ctx.strokeStyle = "#2b6cb0";
        ctx.strokeRect(radiator.x, radiator.y, radiator.w, radiator.h);

        // --- Centered size box inside the radiator ---
        const widthMm = Math.round((radiator.w / gridSize) * MM_PER_GRID);
        const heightMm = Math.round((radiator.h / gridSize) * MM_PER_GRID);
        const sizeText = `${widthMm} √ó ${heightMm} mm`;

        let fontSize = 16;
        ctx.font = `${fontSize}px system-ui, sans-serif`;
        let textW = ctx.measureText(sizeText).width;

        const padX = 12;
        const padY = 8;
        const maxBoxW = radiator.w - 16; // keep some margin inside radiator

        // Shrink font until it fits inside the radiator
        while (textW + padX * 2 > maxBoxW && fontSize > 10) {
          fontSize -= 1;
          ctx.font = `${fontSize}px system-ui, sans-serif`;
          textW = ctx.measureText(sizeText).width;
        }

        const boxW = Math.min(textW + padX * 2, maxBoxW);
        const boxH = fontSize + padY * 2;

        const boxX = radiator.x + radiator.w / 2 - boxW / 2;
        const boxY = radiator.y + radiator.h / 2 - boxH / 2;

        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.strokeStyle = "#ddd";
        ctx.lineWidth = 1;
        ctx.fillRect(boxX, boxY, boxW, boxH);
        ctx.strokeRect(boxX, boxY, boxW, boxH);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#333";
        ctx.fillText(
          sizeText,
          radiator.x + radiator.w / 2,
          radiator.y + radiator.h / 2,
        );

        // Connectors
        const connectors = getConnectors();
        for (const [key, p] of Object.entries(connectors)) {
          let color = "#999";

          if (radiator.inflow === key) color = "#2f855a"; // green
          if (radiator.outflow === key) color = "#c53030"; // red

          ctx.beginPath();
          ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
        }

        // resize handle (bottom-right) ‚Äì inset triangle
        const inset = 10;
        const hx = radiator.x + radiator.w - inset;
        const hy = radiator.y + radiator.h - inset;

        ctx.fillStyle = "#2b6cb0";
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx - 20, hy);
        ctx.lineTo(hx, hy - 20);
        ctx.closePath();
        ctx.fill();
      }

      // Added slider drawing helper below drawConstructionBox()
      function drawTempSliders() {
        const sliderWidth = 6;
        const thumbRadius = 8;

        const top = radiator.y;
        const bottom = radiator.y + radiator.h;
        const height = radiator.h;

        // Map temp -> y
        const mapTempToY = (temp, min, max) =>
          bottom - ((temp - min) / (max - min)) * height;

        // IN slider (left)
        const inX = radiator.x - 20;
        ctx.strokeStyle = "#2f855a";
        ctx.lineWidth = sliderWidth;
        ctx.beginPath();
        ctx.moveTo(inX, top);
        ctx.lineTo(inX, bottom);
        ctx.stroke();

        const inY = mapTempToY(flowTemp, FLOW_MIN, FLOW_MAX);
        ctx.fillStyle = "#2f855a";
        ctx.beginPath();
        ctx.arc(inX, inY, thumbRadius, 0, Math.PI * 2);
        ctx.fill();

        // IN temperature label
        ctx.fillStyle = "#2f855a";
        ctx.font = "15px system-ui, sans-serif";
        ctx.textBaseline = "middle";
        ctx.textAlign = "right";
        ctx.fillText(`${flowTemp}¬∞C`, inX - 12, inY);

        // OUT slider (right)
        const outX = radiator.x + radiator.w + 20;
        ctx.strokeStyle = "#c53030";
        ctx.lineWidth = sliderWidth;
        ctx.beginPath();
        ctx.moveTo(outX, top);
        ctx.lineTo(outX, bottom);
        ctx.stroke();

        const outY = mapTempToY(returnTemp, RETURN_MIN, flowTemp);
        ctx.fillStyle = "#c53030";
        ctx.beginPath();
        ctx.arc(outX, outY, thumbRadius, 0, Math.PI * 2);
        ctx.fill();

        // OUT temperature label
        ctx.fillStyle = "#c53030";
        ctx.font = "15px system-ui, sans-serif";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        ctx.fillText(`${returnTemp}¬∞C`, outX + 12, outY);

        // Reset line width to default so it doesn't leak into other drawings
        ctx.lineWidth = 1;
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawConstructionBox();
        drawRadiator();
        drawTempSliders();
        updateFooterCurrent();
      }

      function snap(value) {
        return Math.round(value / gridSize) * gridSize;
      }

      // Added slider hit-testing helpers below hitConnector()
      function hitInSlider(mx, my) {
        const x = radiator.x - 20;
        return (
          Math.abs(mx - x) < 12 &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        );
      }

      function hitOutSlider(mx, my) {
        const x = radiator.x + radiator.w + 20;
        return (
          Math.abs(mx - x) < 12 &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        );
      }

      function updateFooterCurrent() {
        const deltaT = computeDeltaT();
        const el = document.getElementById("footerCurrent");
        if (!el) return;

        const watts = estimateRadiatorWatts();
        const wattsRounded = Math.round(watts / 50) * 50;

        const estM2_good = wattsRounded / 45;
        const estM2_medium = wattsRounded / 70;
        const estM2_poor = wattsRounded / 100;

        const mediumRoom = Math.max(0, Math.round(estM2_medium));
        const humanText = `Kb. ${mediumRoom} m¬≤-es √°tlagos szoba f≈±t√©s√©re alkalmas`;

        el.innerHTML = `
          <p>
            ‚ö° ~${wattsRounded.toLocaleString()} W
            <span class="info-icon" title="Megjegyz√©s: a radi√°tor gy√°rt√≥k a teljes√≠tm√©nyt √°ltal√°ban EN 442 szerint adj√°k meg (el≈ëremen≈ë 75 ¬∞C / visszat√©r≈ë 65 ¬∞C / szobah≈ëm√©rs√©klet 20 ¬∞C, ŒîT50).">‚ÑπÔ∏è</span>
          </p>
          <p>
            üè†‚ñÅ ~${Math.round(estM2_poor).toLocaleString()} m¬≤&nbsp;&nbsp;
            üè†‚ñÇ‚ñÉ ~${Math.round(estM2_medium).toLocaleString()} m¬≤&nbsp;&nbsp;
            üè†‚ñÇ‚ñÉ‚ñÑ ~${Math.round(estM2_good).toLocaleString()} m¬≤
          </p>
        `;
      }

      function updateCursor(mx, my) {
        const hx = radiator.x + radiator.w;
        const hy = radiator.y + radiator.h;

        if (hitInSlider(mx, my) || hitOutSlider(mx, my)) {
          canvas.style.cursor = "ns-resize";
          return;
        }

        // Resize handle (triangle area)
        const inset = 10;
        const rhx = hx - inset;
        const rhy = hy - inset;

        if (mx > rhx - 24 && mx < rhx && my > rhy - 24 && my < rhy) {
          canvas.style.cursor = "nwse-resize";
          return;
        }

        // Drag body
        if (
          mx >= radiator.x &&
          mx <= radiator.x + radiator.w &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        ) {
          canvas.style.cursor = "move";
          return;
        }

        canvas.style.cursor = "default";
      }

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Added slider dragging start handling
        if (hitInSlider(mx, my)) {
          draggingInSlider = true;
          return;
        }

        if (hitOutSlider(mx, my)) {
          draggingOutSlider = true;
          return;
        }

        const hx = radiator.x + radiator.w;
        const hy = radiator.y + radiator.h;

        // Resize handle (bottom-right) ‚Äì inset triangle area
        const inset = 10;
        const rhx = hx - inset;
        const rhy = hy - inset;

        if (mx > rhx - 24 && mx < rhx && my > rhy - 24 && my < rhy) {
          radiator.resizing = true;
          return;
        }

        // Drag body
        if (
          mx >= radiator.x &&
          mx <= radiator.x + radiator.w &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        ) {
          radiator.dragging = true;
          radiator.dragOffsetX = mx - radiator.x;
          radiator.dragOffsetY = my - radiator.y;
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        updateCursor(mx, my);

        // Added slider dragging handling
        const top = radiator.y;
        const bottom = radiator.y + radiator.h;
        const height = radiator.h;

        const mapYToTemp = (y, min, max) =>
          max - ((y - top) / height) * (max - min);

        if (draggingInSlider) {
          const rawFlow = Math.min(
            FLOW_MAX,
            Math.max(FLOW_MIN, mapYToTemp(my, FLOW_MIN, FLOW_MAX)),
          );
          flowTemp = Math.round(rawFlow / 5) * 5;

          // Automatically keep outflow 10¬∞C lower than inflow for convenience
          returnTemp = Math.max(RETURN_MIN, flowTemp - 10);

          redraw();
          return;
        }

        if (draggingOutSlider) {
          const rawReturn = Math.min(
            flowTemp,
            Math.max(RETURN_MIN, mapYToTemp(my, RETURN_MIN, flowTemp)),
          );
          returnTemp = Math.round(rawReturn / 5) * 5;
          redraw();
          return;
        }

        if (radiator.resizing) {
          const minSize = gridSize * 2; // 200 mm minimum (2 cells √ó 100 mm per cell)
          radiator.w = Math.max(minSize, snap(mx - radiator.x));
          radiator.h = Math.max(minSize, snap(my - radiator.y));
          redraw();
          return;
        }

        if (radiator.dragging) {
          radiator.x = snap(mx - radiator.dragOffsetX);
          radiator.y = snap(my - radiator.dragOffsetY);
          redraw();
        }
      });

      canvas.addEventListener("mouseup", () => {
        radiator.resizing = false;
        radiator.dragging = false;
        draggingInSlider = false;
        draggingOutSlider = false;
      });

      canvas.addEventListener("mouseleave", () => {
        radiator.resizing = false;
        radiator.dragging = false;
        draggingInSlider = false;
        draggingOutSlider = false;
      });

      document
        .getElementById("radiatorType")
        .addEventListener("change", (e) => {
          radiatorType = e.target.value;
          redraw();
        });

      document.getElementById("roomTemp").addEventListener("input", (e) => {
        roomTemp = Number(e.target.value);
        redraw();
      });

      // Initial fullscreen sizing + first draw (after all constants/functions exist)
      resizeCanvas();
    </script>
  </body>
</html>
z
