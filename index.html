<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Radiátor szimulátor – Alfa</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        background: #f5f5f5;
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
        background: white;
        margin: 0;
        padding: 0;
      }

      header#controls {
        height: 60px;
        display: flex;
        align-items: center;
        padding: 0 16px;
        background: #fafafa;
        border-bottom: 1px solid #ddd;
        box-sizing: border-box;
      }

      header#controls label {
        font-size: 14px;
      }

      header#controls select {
        margin-left: 8px;
        padding: 4px 8px;
      }
      footer {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        font-size: 14px;
        color: #444;
        background: #fafafa;
        border-top: 1px solid #ddd;
        padding: 8px 12px;
        box-sizing: border-box;
      }
      #footerCurrent {
        font-weight: 500;
      }
    </style>
  </head>
  <body>
    <header id="controls">
      <label style="margin-right: 16px">
        Radiátor típusa:
        <select id="radiatorType">
          <option value="11">Acél – 11-es típus</option>
          <option value="21">Acél – 21-es típus</option>
          <option value="22" selected>Acél – 22-es típus</option>
          <option value="33">Acél – 33-as típus</option>
          <option value="aluminium">Alumínium</option>
        </select>
      </label>

      <label style="margin-right: 16px">
        Szobahőmérséklet cel:
        <input id="roomTemp" type="number" min="5" max="30" step="1" />
        °C
      </label>
    </header>

    <canvas id="canvas"></canvas>

    <footer>
      <div>
        Megjegyzés: a radiátor gyártók a teljesítményt általában EN 442 szerint
        adják meg (előremenő 75 °C / visszatérő 65 °C / szobahőmérséklet 20 °C,
        ΔT50).
      </div>
      <div id="footerCurrent" style="margin-top: 4px"></div>
    </footer>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        const headerHeight = document.getElementById("controls").offsetHeight;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - headerHeight;
        canvas.style.marginTop = "0";

        // Center radiator horizontally on load/resize
        radiator.x = snap((canvas.width - radiator.w) / 2);

        redraw();
      }

      window.addEventListener("resize", resizeCanvas);

      const gridSize = 60;
      const MM_PER_GRID = 100; // 1 grid cell = 200 mm (visual grid stays the same)
      const CONSTRUCTION_GAP = 14;
      const CONSTRUCTION_HEIGHT = 28;

      function drawGrid() {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#eee";
        for (let x = 0; x <= canvas.width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      function drawConstructionBox() {
        // Position: attached to radiator, above it, with a gap
        const x = radiator.x;
        const y = radiator.y - CONSTRUCTION_GAP - CONSTRUCTION_HEIGHT;
        const w = radiator.w;
        const h = CONSTRUCTION_HEIGHT;

        // Background outline
        ctx.strokeStyle = "#aaa";
        ctx.strokeRect(x, y, w, h);

        let sequence;

        switch (radiatorType) {
          case "11":
            sequence = ["P", "F"];
            break;
          case "21":
            sequence = ["P", "F", "P"];
            break;
          case "22":
            sequence = ["P", "F", "P", "F"];
            break;
          case "33":
            sequence = ["P", "F", "P", "F", "P", "F"];
            break;
          case "aluminium":
            sequence = ["A"];
            break;
        }

        if (sequence[0] === "A") {
          ctx.fillStyle = "#c8c8c8";
          ctx.fillRect(x, y, w, h);

          ctx.strokeStyle = "#c8c8c8";
          for (let sx = x + 6; sx < x + w; sx += 10) {
            ctx.beginPath();
            ctx.moveTo(sx, y + 4);
            ctx.lineTo(sx, y + h - 4);
            ctx.stroke();
          }
          return;
        }

        const unitW = w / sequence.length;

        for (let i = 0; i < sequence.length; i++) {
          const bx = x + i * unitW;
          const type = sequence[i];

          if (type === "P") {
            // Panel
            ctx.fillStyle = "#c8c8c8";
            ctx.fillRect(bx, y, unitW, h);
          } else {
            // Convector (vertical snake/zig-zag abstraction)
            ctx.strokeStyle = "#c8c8c8";
            ctx.lineWidth = 2;

            const padding = 4;
            const startY = y + padding;
            const endY = y + h - padding;
            const stepX = 6;

            ctx.beginPath();

            let goingDown = true;
            let cx = bx + padding;

            ctx.moveTo(cx, startY);

            while (cx < bx + unitW - padding) {
              if (goingDown) {
                ctx.lineTo(cx, endY);
              } else {
                ctx.lineTo(cx, startY);
              }
              cx += stepX;
              ctx.lineTo(cx, goingDown ? endY : startY);
              goingDown = !goingDown;
            }

            ctx.stroke();
            ctx.lineWidth = 1;
          }
        }
      }

      // Added slider state + bounds
      let deltaDrop = 10;

      let flowTemp = 70; // IN temperature
      let returnTemp = 60; // OUT temperature

      const FLOW_MIN = 40;
      const FLOW_MAX = 90;
      const RETURN_MIN = 20;

      let draggingInSlider = false;
      let draggingOutSlider = false;

      const radiator = {
        x: gridSize * 2,
        y: gridSize * 2,
        w: gridSize * 12, // 1200 mm default width
        h: gridSize * 6, // 600 mm default height
        resizing: false,
        dragging: false,
        dragOffsetX: 0,
        dragOffsetY: 0,
        inflow: "tl", // default IN: top-left
        outflow: "tr", // default OUT: top-right
      };

      let radiatorType = "22";
      let roomTemp = 22;
      document.getElementById("roomTemp").value = roomTemp;

      function getConnectors() {
        return {
          tl: { x: radiator.x, y: radiator.y },
          tr: { x: radiator.x + radiator.w, y: radiator.y },
        };
      }

      // Updated computeDeltaT() to use explicit temps
      function computeDeltaT() {
        const avgWaterTemp = (flowTemp + returnTemp) / 2;
        return Math.max(5, avgWaterTemp - roomTemp);
      }

      // Updated getFlowReturnTemps() to use explicit temps
      function getFlowReturnTemps() {
        return { flow: flowTemp, ret: returnTemp };
      }

      function estimateRadiatorWatts() {
        // Face area (m²)
        const widthM = ((radiator.w / gridSize) * MM_PER_GRID) / 1000;
        const heightM = ((radiator.h / gridSize) * MM_PER_GRID) / 1000;
        const areaM2 = Math.max(0, widthM * heightM);

        // EN 442 calibrated baselines (ΔT50), per m² of front face
        // Aligned to real catalogue data (e.g. Stelrad / Wickes)
        const wattsPerM2ByType = {
          11: 1500, // ~Type 11 600×1200 ≈ 1000–1100 W
          21: 2200, // between 11 and 22
          22: 2800, // ~Type 22 600×1200 ≈ 1900–2050 W
          33: 4000, // ~Type 33 600×1200 ≈ 2800–3000 W
          aluminium: 3000,
        };

        const baseWattsPerM2 = wattsPerM2ByType[radiatorType] ?? 1200;
        const baseWatts = areaM2 * baseWattsPerM2;

        // Estimate ΔT from user-friendly inputs
        const deltaT = computeDeltaT();

        // Radiator output scaling (non-linear)
        const exponent = 1.3;
        const scaledWatts = baseWatts * Math.pow(deltaT / 50, exponent);

        return scaledWatts;
      }

      function drawRadiator() {
        ctx.lineWidth = 1;

        // Compute wattage first so color can reflect output strength
        const watts = estimateRadiatorWatts();
        const wattsRounded = Math.round(watts / 50) * 50;

        // White radiator body
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(radiator.x, radiator.y, radiator.w, radiator.h);

        // Snake/zig-zag texture over the radiator (subtle, light gray)
        ctx.strokeStyle = "#c8c8c8";
        ctx.lineWidth = 2;

        const padding = 6;
        const top = radiator.y + padding;
        const bottom = radiator.y + radiator.h - padding;
        const stepX = 10;

        ctx.beginPath();
        let goingDown = true;
        let texX = radiator.x + padding;

        ctx.moveTo(texX, top);

        while (texX < radiator.x + radiator.w - padding) {
          if (goingDown) {
            ctx.lineTo(texX, bottom);
          } else {
            ctx.lineTo(texX, top);
          }
          texX += stepX;
          ctx.lineTo(texX, goingDown ? bottom : top);
          goingDown = !goingDown;
        }

        ctx.stroke();
        ctx.lineWidth = 1;

        ctx.strokeStyle = "#2b6cb0";
        ctx.strokeRect(radiator.x, radiator.y, radiator.w, radiator.h);

        // --- Centered size box inside the radiator ---
        const widthMm = Math.round((radiator.w / gridSize) * MM_PER_GRID);
        const heightMm = Math.round((radiator.h / gridSize) * MM_PER_GRID);
        const sizeText = `${widthMm} × ${heightMm} mm`;

        let fontSize = 16;
        ctx.font = `${fontSize}px system-ui, sans-serif`;
        let textW = ctx.measureText(sizeText).width;

        const padX = 12;
        const padY = 8;
        const maxBoxW = radiator.w - 16; // keep some margin inside radiator

        // Shrink font until it fits inside the radiator
        while (textW + padX * 2 > maxBoxW && fontSize > 10) {
          fontSize -= 1;
          ctx.font = `${fontSize}px system-ui, sans-serif`;
          textW = ctx.measureText(sizeText).width;
        }

        const boxW = Math.min(textW + padX * 2, maxBoxW);
        const boxH = fontSize + padY * 2;

        const boxX = radiator.x + radiator.w / 2 - boxW / 2;
        const boxY = radiator.y + radiator.h / 2 - boxH / 2;

        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.strokeStyle = "#ddd";
        ctx.lineWidth = 1;
        ctx.fillRect(boxX, boxY, boxW, boxH);
        ctx.strokeRect(boxX, boxY, boxW, boxH);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#333";
        ctx.fillText(
          sizeText,
          radiator.x + radiator.w / 2,
          radiator.y + radiator.h / 2,
        );

        // --- Info for below radiator ---
        // (widthMm, heightMm) already computed above for the size box
        const estM2_good = wattsRounded / 45;
        const estM2_medium = wattsRounded / 70;
        const estM2_poor = wattsRounded / 100;

        // Connectors
        const connectors = getConnectors();
        for (const [key, p] of Object.entries(connectors)) {
          let color = "#999";

          if (radiator.inflow === key) color = "#2f855a"; // green
          if (radiator.outflow === key) color = "#c53030"; // red

          ctx.beginPath();
          ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
        }

        // resize handle (bottom-right) – inset triangle
        const inset = 10;
        const hx = radiator.x + radiator.w - inset;
        const hy = radiator.y + radiator.h - inset;

        ctx.fillStyle = "#2b6cb0";
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx - 20, hy);
        ctx.lineTo(hx, hy - 20);
        ctx.closePath();
        ctx.fill();

        // ---- Info text below radiator ----
        const infoX = radiator.x + radiator.w / 2;
        let infoY = radiator.y + radiator.h + 18;

        // Background box for info text
        const mediumRoom = Math.max(0, Math.round(estM2_medium));
        const humanText = `Kb. ${mediumRoom} m²-es átlagos szoba fűtésére alkalmas`;

        ctx.font = "15px system-ui, sans-serif";
        const paddingX = 10;
        const paddingY = 6;
        const lineHeights = [16, 16, 16, 16, 18];

        ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
        ctx.strokeStyle = "#ddd";
        ctx.lineWidth = 1;

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillStyle = "#333";
        ctx.backgroundColor = "rgba(255, 255, 255, 0.8)";

        // Wattage
        ctx.font = "13px system-ui, sans-serif";
        ctx.fillText(`~${wattsRounded.toLocaleString()} W`, infoX, infoY);
        infoY += 16;

        // Room size estimates by insulation
        ctx.font = "13px system-ui, sans-serif";
        ctx.fillStyle = "#444";
        ctx.fillText(
          `Gyenge szigetelês: ~${Math.max(0, Math.round(estM2_poor)).toLocaleString()} m²`,
          infoX,
          infoY,
        );
        infoY += 16;

        ctx.fillText(
          `Közepes szigetelês: ~${mediumRoom.toLocaleString()} m²`,
          infoX,
          infoY,
        );
        infoY += 16;

        ctx.fillText(
          `Jó szigetelês: ~${Math.max(0, Math.round(estM2_good)).toLocaleString()} m²`,
          infoX,
          infoY,
        );
        infoY += 18;
        ctx.font = "14px system-ui, sans-serif";
        ctx.fillStyle = "#333";
        ctx.fillText(humanText, infoX, infoY);
      }

      // Added slider drawing helper below drawConstructionBox()
      function drawTempSliders() {
        const sliderWidth = 6;
        const thumbRadius = 8;

        const top = radiator.y;
        const bottom = radiator.y + radiator.h;
        const height = radiator.h;

        // Map temp -> y
        const mapTempToY = (temp, min, max) =>
          bottom - ((temp - min) / (max - min)) * height;

        // IN slider (left)
        const inX = radiator.x - 20;
        ctx.strokeStyle = "#2f855a";
        ctx.lineWidth = sliderWidth;
        ctx.beginPath();
        ctx.moveTo(inX, top);
        ctx.lineTo(inX, bottom);
        ctx.stroke();

        const inY = mapTempToY(flowTemp, FLOW_MIN, FLOW_MAX);
        ctx.fillStyle = "#2f855a";
        ctx.beginPath();
        ctx.arc(inX, inY, thumbRadius, 0, Math.PI * 2);
        ctx.fill();

        // IN temperature label
        ctx.fillStyle = "#2f855a";
        ctx.font = "15px system-ui, sans-serif";
        ctx.textBaseline = "middle";
        ctx.textAlign = "right";
        ctx.fillText(`${flowTemp}°C`, inX - 12, inY);

        // OUT slider (right)
        const outX = radiator.x + radiator.w + 20;
        ctx.strokeStyle = "#c53030";
        ctx.lineWidth = sliderWidth;
        ctx.beginPath();
        ctx.moveTo(outX, top);
        ctx.lineTo(outX, bottom);
        ctx.stroke();

        const outY = mapTempToY(returnTemp, RETURN_MIN, flowTemp);
        ctx.fillStyle = "#c53030";
        ctx.beginPath();
        ctx.arc(outX, outY, thumbRadius, 0, Math.PI * 2);
        ctx.fill();

        // OUT temperature label
        ctx.fillStyle = "#c53030";
        ctx.font = "15px system-ui, sans-serif";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        ctx.fillText(`${returnTemp}°C`, outX + 12, outY);

        // Reset line width to default so it doesn't leak into other drawings
        ctx.lineWidth = 1;
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawConstructionBox();
        drawRadiator();
        drawTempSliders();
        updateFooterCurrent();
      }

      function snap(value) {
        return Math.round(value / gridSize) * gridSize;
      }

      // Added slider hit-testing helpers below hitConnector()
      function hitInSlider(mx, my) {
        const x = radiator.x - 20;
        return (
          Math.abs(mx - x) < 12 &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        );
      }

      function hitOutSlider(mx, my) {
        const x = radiator.x + radiator.w + 20;
        return (
          Math.abs(mx - x) < 12 &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        );
      }

      function updateFooterCurrent() {
        const deltaT = computeDeltaT();
        const el = document.getElementById("footerCurrent");
        if (!el) return;

        el.textContent = `Jelenlegi: előremenő ${flowTemp} °C / visszatérő ${returnTemp} °C / szobahőmérséklet ${roomTemp} °C, ΔT ≈ ${Math.round(
          deltaT,
        )} °C`;
      }

      function updateCursor(mx, my) {
        const hx = radiator.x + radiator.w;
        const hy = radiator.y + radiator.h;

        if (hitInSlider(mx, my) || hitOutSlider(mx, my)) {
          canvas.style.cursor = "ns-resize";
          return;
        }

        // Resize handle (triangle area)
        const inset = 10;
        const rhx = hx - inset;
        const rhy = hy - inset;

        if (mx > rhx - 24 && mx < rhx && my > rhy - 24 && my < rhy) {
          canvas.style.cursor = "nwse-resize";
          return;
        }

        // Drag body
        if (
          mx >= radiator.x &&
          mx <= radiator.x + radiator.w &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        ) {
          canvas.style.cursor = "move";
          return;
        }

        canvas.style.cursor = "default";
      }

      canvas.addEventListener("mousedown", (e) => {
        canvas.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const t = e.touches[0];
            const mx = t.clientX - rect.left;
            const my = t.clientY - rect.top;

            // Start slider drags
            if (hitInSlider(mx, my)) {
              draggingInSlider = true;
              return;
            }
            if (hitOutSlider(mx, my)) {
              draggingOutSlider = true;
              return;
            }

            const hx = radiator.x + radiator.w;
            const hy = radiator.y + radiator.h;

            // Resize handle (triangle area)
            const inset = 10;
            const rhx = hx - inset;
            const rhy = hy - inset;

            if (mx > rhx - 24 && mx < rhx && my > rhy - 24 && my < rhy) {
              radiator.resizing = true;
              return;
            }

            // Drag body
            if (
              mx >= radiator.x &&
              mx <= radiator.x + radiator.w &&
              my >= radiator.y &&
              my <= radiator.y + radiator.h
            ) {
              radiator.dragging = true;
              radiator.dragOffsetX = mx - radiator.x;
              radiator.dragOffsetY = my - radiator.y;
            }
          },
          { passive: false },
        );
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Added slider dragging start handling
        if (hitInSlider(mx, my)) {
          draggingInSlider = true;
          return;
        }

        if (hitOutSlider(mx, my)) {
          draggingOutSlider = true;
          return;
        }

        const hx = radiator.x + radiator.w;
        const hy = radiator.y + radiator.h;

        // Resize handle (bottom-right) – inset triangle area
        const inset = 10;
        const rhx = hx - inset;
        const rhy = hy - inset;

        if (mx > rhx - 24 && mx < rhx && my > rhy - 24 && my < rhy) {
          radiator.resizing = true;
          return;
        }

        // Drag body
        if (
          mx >= radiator.x &&
          mx <= radiator.x + radiator.w &&
          my >= radiator.y &&
          my <= radiator.y + radiator.h
        ) {
          radiator.dragging = true;
          radiator.dragOffsetX = mx - radiator.x;
          radiator.dragOffsetY = my - radiator.y;
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        canvas.addEventListener(
          "touchmove",
          (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const t = e.touches[0];
            const mx = t.clientX - rect.left;
            const my = t.clientY - rect.top;

            const top = radiator.y;
            const bottom = radiator.y + radiator.h;
            const height = radiator.h;

            const mapYToTemp = (y, min, max) =>
              max - ((y - top) / height) * (max - min);

            if (draggingInSlider) {
              const rawFlow = Math.min(
                FLOW_MAX,
                Math.max(FLOW_MIN, mapYToTemp(my, FLOW_MIN, FLOW_MAX)),
              );
              flowTemp = Math.round(rawFlow / 5) * 5;
              returnTemp = Math.max(RETURN_MIN, flowTemp - 10);
              redraw();
              return;
            }

            if (draggingOutSlider) {
              const rawReturn = Math.min(
                flowTemp,
                Math.max(RETURN_MIN, mapYToTemp(my, RETURN_MIN, flowTemp)),
              );
              returnTemp = Math.round(rawReturn / 5) * 5;
              redraw();
              return;
            }

            if (radiator.resizing) {
              const minSize = gridSize * 2;
              radiator.w = Math.max(minSize, snap(mx - radiator.x));
              radiator.h = Math.max(minSize, snap(my - radiator.y));
              redraw();
              return;
            }

            if (radiator.dragging) {
              radiator.x = snap(mx - radiator.dragOffsetX);
              radiator.y = snap(my - radiator.dragOffsetY);
              redraw();
            }
          },
          { passive: false },
        );
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        updateCursor(mx, my);

        // Added slider dragging handling
        const top = radiator.y;
        const bottom = radiator.y + radiator.h;
        const height = radiator.h;

        const mapYToTemp = (y, min, max) =>
          max - ((y - top) / height) * (max - min);

        if (draggingInSlider) {
          const rawFlow = Math.min(
            FLOW_MAX,
            Math.max(FLOW_MIN, mapYToTemp(my, FLOW_MIN, FLOW_MAX)),
          );
          flowTemp = Math.round(rawFlow / 5) * 5;

          // Automatically keep outflow 10°C lower than inflow for convenience
          returnTemp = Math.max(RETURN_MIN, flowTemp - 10);

          redraw();
          return;
        }

        if (draggingOutSlider) {
          const rawReturn = Math.min(
            flowTemp,
            Math.max(RETURN_MIN, mapYToTemp(my, RETURN_MIN, flowTemp)),
          );
          returnTemp = Math.round(rawReturn / 5) * 5;
          redraw();
          return;
        }

        if (radiator.resizing) {
          const minSize = gridSize * 2; // 200 mm minimum (2 cells × 100 mm per cell)
          radiator.w = Math.max(minSize, snap(mx - radiator.x));
          radiator.h = Math.max(minSize, snap(my - radiator.y));
          redraw();
          return;
        }

        if (radiator.dragging) {
          radiator.x = snap(mx - radiator.dragOffsetX);
          radiator.y = snap(my - radiator.dragOffsetY);
          redraw();
        }
      });

      canvas.addEventListener("mouseup", () => {
        radiator.resizing = false;
        radiator.dragging = false;
        draggingInSlider = false;
        draggingOutSlider = false;
      });

      canvas.addEventListener("touchend", () => {
        radiator.resizing = false;
        radiator.dragging = false;
        draggingInSlider = false;
        draggingOutSlider = false;
      });

      canvas.addEventListener("mouseleave", () => {
        radiator.resizing = false;
        radiator.dragging = false;
        draggingInSlider = false;
        draggingOutSlider = false;
      });

      canvas.addEventListener("touchcancel", () => {
        radiator.resizing = false;
        radiator.dragging = false;
        draggingInSlider = false;
        draggingOutSlider = false;
      });

      document
        .getElementById("radiatorType")
        .addEventListener("change", (e) => {
          radiatorType = e.target.value;
          redraw();
        });

      document.getElementById("roomTemp").addEventListener("input", (e) => {
        roomTemp = Number(e.target.value);
        redraw();
      });

      // Initial fullscreen sizing + first draw (after all constants/functions exist)
      resizeCanvas();
    </script>
  </body>
</html>
z
